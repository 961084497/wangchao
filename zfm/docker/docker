docker run --name initcentos -itd 10.254.232.125:5000/init/centos7.5 /bin/bash   ####--name 新的名字 -itd 镜像名字
docker exec -it name
docker commit 95b5243264d0 10.254.232.125:5000/nginx/centos7.5   ####制作镜像的时候顺便把名字换成push时候的名字 这样正好可以放到仓库  commit后面是跑的容器名字


---------------------镜像仓库-----------------------------
1 解决https问题  
cat /etc/docker/daemon.json   写上{ "insecure-registries":["10.254.232.125:5000"] }
好像这个也要改 cat /usr/lib/systemd/system/docker.service   ExecStart=/usr/bin/dockerd --registry-mirror=http://019a7061.m.daocloud.io  --insecure-registry 10.254.232.125:5000

2 制作仓库
docker pull registry
docker run -d -ti --restart always --name docker-hub -p 5000:5000 -v /docker-hub/registry:/var/lib/registry registry  #######/docker-hub/registry 必须是存在的目录
docker run --name startnginxv1 -p 333:80 -v /data/www:/data/dddd -itd yunxingnginx /usr/local/nginx/sbin/start.sh  ########这种写法也ok 但是顺序错了也造成启动不了

3 最红要的逻辑关系 
	1)如果你是想吧已有的镜像添加进仓库 那直接docker tag old new 就好了 （对应下面的commit  new的镜像名字可以直接写成ip:5000/xxxx）
	2)如果是新的容器打成镜像 那必须先要commit（commit 上面写了）
	3)上面的新的镜像名字可以直接写成ip:5000/xxxx  
	4)docker push new的名字  他直接就可以认出了ip和端口 多方便
	5)curl http://10.254.232.125:5000/v2/_catalog 查看仓库所有的镜像
	5)docker pull ip:5000/xxxxxx就可以直接拉取了

--------------------------------------------------------------------

4 如果不使用dockerfile启动的话 可以在里面创建个脚本来阻塞也是可以的
	1)--------脚本内容如下--------tailf阻塞了	
		touch wangchao.txt
		echo "123">>wangchao.txt
		touch chaowang.txt
		tailf chaowang.txt

---------------------------------------------------------------------
5 附一个完整的启动参数
	 docker run \
	-d \
	--name private_registry --restart=always \
	-u root \
	-p 5000:5000 \
	-v /docker/data/private_registry:/var/lib/registry \
	-v /docker/certs:/certs \
	-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
	-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
	registry:2

-----------------------------------------------------------------------
6 使用docker-compose简化docker run 运行参数
	-v的参数可以用到很多地方 比如说共享dns的那个配置文件  方便查看日志

------------------------------------------------------------------------
7 解决systemctl的问题
	--privileged=true centos:7 /usr/sbin/init

-------------------------------------------------------------------------
7.1
安装docker-ce 
yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
yum install docker-ce
-----------------------------------------------------------------------
8 dockerfile
	docker build -t zhang ./   (后面是dockerfile的路劲)    ###zhang 是你新打的镜像名字

9 docker挂载
	docker run -itd -v /data/wangchaodata/:/data/wangchaodata --name newcentos01 centos   ############如果是这种挂载 则宿主机的/data/wangchaodata和docker里面挂在的一模一样  你增我就增 你减我就减
	docker run -itd -v /data/wangchaodata/ --name newcentos01 centos   ################如果是这种的 则默认挂在在docker的/目录 其实也是/data/wangchaodata 其实上面的参数就是docker里面挂在的目录 但是在宿主机中挂在的目录要通过 docker inspect来看到  如果docker容器关闭了 宿主机文件是不会消失的

------------------------------------------------
10  docker创建自己的路由  就是给docker分配容器ip地址

	1 	首先 dockers network ls  看一下目前的网络名称有几种方式
	2	在 docker network create --subnet=10.0.2.0/8 docker-br0    ##################创建一个网桥名字 docker-br0  是桥接模式  分配ip地址段为10.0.2网段
	3	docker run -itd --net docker-br0 --ip 10.0.2.3 --name wc-centos cento	################给这个容器分配一个固定ip 10.0.2.3 使用之前的docker-br0这个网桥 之后分配的ip地址就是固定		       的10.0.2.3了
	4	用何种方式创建的网桥  他们只能ping通自身网桥网段的机器
	5	2个容器之间要是互相访问的话
		route add -net 172.17.0.0/16 (docker网段) gw 100.73.18.106 (宿主机IP)
		#在100.73.18.108上面添加
		route add -net 172.18.0.0/16 (docker网段) gw 100.73.18.108 (宿主机IP)

	6	-m 100m --memory-swap=100m   ##################限制最大的使用内存超过就会kill
		--cpuset-cpus=7  (注意1.6版本才是--cpuset-cpus，1.6版本以下是--cpuset)############ 绑定线程数
